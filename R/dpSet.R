#' Create and manage datapuppy \code{sets} and \code{batches}
#'
#' Datapuppy \code{sets} are collections of data \code{batches} to be loaded
#' into a single database.  \code{Batches} are collections of records derived
#' from a single data file (e.g., a data file downloaded from a data logger or a
#' spreadsheet that contains field observations).
#'
#' \code{Sets} are collections of data \code{batches}.  The concept of a
#' \code{set} was developed assuming that a \code{set} would represent all of
#' the data stored in a particular database.  Thus, each \code{set} is always
#' associated with a single database.  (Technically, however, there is no reason
#' a single database couldn't be associated with and contain multiple
#' \code{sets}.)
#'
#' A \code{batch} is a collection of data points that have been imported from a
#' single data file.  For instance, when a data logger is downloaded, it creates
#' a data file with many records, where each record may contain observations of
#' several different metrics. All (or a subset) of those observations can be
#' collected into a \code{batch}.
#'
#' Note that datapuppy makes a few assumptions about the columns in the
#' \code{batchesTable}, \code{dataTable}, and \code{typesTable} of the database:
#'
#' 1) Each table must contain an autonumber field that is designated as the
#' primary key for the table
#'
#' 2) the \code{dataTable} must contain at least two foreign keys, one that
#' refers to and is named the same as the primary key column of the
#' \code{batchesTable}, and one that refers to and is named the same as the
#' primary key column of the \code{typesTable}.
#'
#' \code{dpCheckSet} reads the set stored at \code{setPath} and compares the
#' parameters used to create the stored set the the parameters required by
#' \code{dpSet()}.
#'
#' @param setPath A character string containing the path to the folder that will
#'   house the \code{set}.  The folder must exist and be empty when a new
#'   \code{set} is created.  The path can be fully specified or relative to the
#'   R working directory.
#' @param conndectionParams A \code{dpConnectionParams} object returned from
#'   \code{\link{dpConnectionParams()}} describing the location and credentials
#'   for the database associated with a \code{set}.
#' @param batchRowColumnName A character string containing the name of a
#'   column in the \code{dataTable} of the database; the column is used to store
#'   the row number of the \code{dataValues data.frame} that was the source of
#'   the datum.  (See \code{\link{dpBatch}} for more information on the
#'   \code{dataValues data.frame}).
#' @param batchNameColumnName A character string containing the name of a column
#'   in the \code{batchTable} of the database that stores a unique name for the
#'   batch.  This name should be meaningful to a human to identify the batch,
#'   not the serial number (primary key) assigned to the batch automatically by
#'   datapuppy.
#' @param batchesTableName A character string containing the name of the
#'   \code{batchesTable} in the database.
#' @param dataTableName A character string containing the name of the
#'   \code{dataTable} in the database.
#' @param typesTableName A character string containing the name of the
#'   \code{typesTable} in the database.
#' @return \code{dpSet()} returns a dpSet object that references both the
#'   storage location (file folder) of the \code{set} and the database
#'   associated with the \code{set}.  This object should be assigned to a
#'   variable so that it can be passed to datapuppy functions that help manage
#'   \code{batches} within the \code{set}.  Note that \code{dbSet()} also saves
#'   a copy of the parameters passed to \code{dpSet()} (technically, it saves the
#'   results of \code{as.list(match.call())}) to a file called "dpSet.rData" in
#'   the folder specified by \code{setPath}.
#' @export
dpSet = function(
  setPath,
  connectionParams,
  batchRowColumnName,
  datumValueColumnName,
  datumTypeColumnName,
  batchNameColumnName,
  batchesTableName,
  dataTableName,
  typesTableName) {

  setPath = dpCheckPath(setPath)
  if(length(list.files(setPath))>0) {
    stop("A Datapuppy 'set' can not be created in '", setPath, "' because the folder is not empty.  Please choose an empty folder to create a new 'set.'")
  }

  # make a list of the parameters passed to this function
  paramList = as.list(match.call())
  paramList = paramList[2:(length(paramList))]

  newSet = .dpSetFromParamList(paramList)

  #The parameter list generated by as.list(match.call()) puts the name of the
  #connectionParams object in the list of arguments, rather than the object
  #itself. So we put the object in the parameter list before saving it to
  #disk.
  paramList$connectionParams = connectionParams

  #Save the parameters to disk so that we can regenerate the set at any time using
  #dpLoadSet().
  dpSaveSetParamList(paramList)
  return(newSet)
}

#' @rdname dpSet
#' @export
dpLoadSet = function(setPath) {
  paramList = dpLoadSetParamList(setPath)
  return(.dpSetFromParamList(paramList))
}

#' @rdname dpSet
#' @return \code{dpCheckSet()} returns a list containing two character vectors.
#'   The first vector, named "missingParamters", contains the names of
#'   parameters required by dpSet() that are missing from the stored set.  The
#'   second vector, named "extraParamters" contains the names of any extra
#'   parameters in the stored set, which should be removed.  When
#'   \code{reportError} is TRUE, the same information is printed as an error
#'   message to the user, and the list containing "missingParameters" and
#'   "extraParamters" is returned invisibly (see \code{\link{invisible}}).
#' @param reportError Boolean value when set to \code{TRUE} causes
#'   \code{dpCheckSet} to print a message and stops execution.  Set to
#'   \code{FALSE}, any errors are returned in a list (see code{Value} section,
#'   below.)
#' @export
dpCheckSet = function(setPath, reportError = TRUE) {
  #Load the call list without validating so we get the call list even if there
  #is an error in it
  paramList = dpLoadSetParamList(setPath, validate = FALSE)
  #Validate the list.  Return the results of the validation to the user.
  return(.dpValidateSetParamList(paramList, reportError))
}

#' When \code{dpSet()} is called, the function creates a file called
#' "dpSet.rData" in the location specified by the \code{setPath} parameter. That
#' file contains a list of the parameters passed to \code{dpSet()}.  When a set
#' is reloaded from disk, the list of the parameters is loaded and passed to
#' \code{dpSet()} to recreate the set.
#'
#' \code{dpLoadSetParamList()} returns the list of parameters that was originally
#' passed to \code{dpSet()} to create the set. By default, the list will be
#' validated against \code{formals(dpSet)} and an error will be thown if the
#' call list doesn't match the dpSet function.  If validate=FALSE, the function
#' will return the loaded parameter list, so that an invalid call list can be
#' inspected or repaired.
dpLoadSetParamList = function(setPath, validate = TRUE) {
  setPath = dpCheckPath(setPath)
  fileName = dpCheckPath(setPath, "dpSet.rData")
  load(file = fileName)
  if(validate) {
    .dpValidateSetParamList(paramList, reportError = TRUE)
  }
  paramList[["setPath"]] = setPath
  return(paramList)
}

dpSaveSetParamList = function(paramList, validate = TRUE) {
  fileName = dpCheckPath(paramList$setPath, "dpSet.rData")
  if(validate) {
    .dpValidateSetParamList(paramList, reportError = TRUE)
  }
  save(paramList, file = fileName)
}

# Compares a call list to the results of formals(dpSet).  If reportError is
# TRUE, function throws an error and stops execution.  If FALSE, errors are
# returned in a list.  See dpCheckSet() for explanation of error list.
.dpValidateSetParamList = function(paramList, reportError) {
  # get parameters from the dpSet
  paramNames = sort(names(paramList))

  # investigate parameters required by current implementation of dpSet
  formalNames = sort(names(formals(dpSet)))

  # compare parameter sets and report missing or extra values.
  badValues = list(missingValues = "", extraValues = "")
  errorMsg = ""
  if(!identical(paramNames, formalNames)) {
    badValues[[1]] = formalNames[!(formalNames %in% paramNames)]
    badValues[[2]] = paramNames[!(paramNames %in% formalNames)]
    if(length(needed)>0) {
      errorMsg = paste0("The following parameters are missing from the stored set: ", paste0(needed, collapse = ", "), "\n  ")
    }
    if(length(extras)>0) {
      errorMsg = paste0(errorMsg, "The following extra parameters should be removed from the stored set: ", paste0(extras, collapse = ", "))
    }
  }
  if(reportError) {
    if(nchar(errorMsg)>0) {
      stop(errorMsg)
    }
  }
  return(badValues)
}

.dpValidateSet = function(set) {

  checkForMissingColumn = function(columnName, columnNames, tableName) {
    if (!(columnName %in% columnNames)) {
      stop(
        "'",
        columnName,
        "' must be a column in the table '",
        tableName,
        ".'\nThe columns in the table are: ",
        paste(columnNames, collapse = ", "),
        "."
      )
    }
  }

  connection = dpConnect(set$connectionParams)

  existingTables = RODBC::sqlTables(connection)$TABLE_NAME
  missingTables = !(set$db$tables %in% existingTables)
  if (any(missingTables)) {
    RODBC::odbcClose(connection)
    stop("The following requested tables do not exist in the database: ",
         paste(set$db$tables[missingTables], collapse = ", "), "\n",
         "Existing tables are:",
         paste(existingTables, collapse = ", ")
    )
  }

  # ensure batchRowColumn is in dataTable
  checkForMissingColumn(
    set$db$batchRowColumnName,
    set$db$columns$dataTableColumns,
    set$db$tables$dataTableName
  )

  # ensure datumValueColumn is in dataTable
  checkForMissingColumn(
    set$db$datumValueColumn,
    set$db$columns$dataTableColumns,
    set$db$tables$dataTableName
  )

  # ensure datumTypeColumn is in typesTable
  checkForMissingColumn(
    set$db$datumTypeColumn,
    set$db$columns$typesTableColumns,
    set$db$tables$typesTableName
  )

  # ensure batchNameColumnName is in batchesTable
  checkForMissingColumn(
    set$db$batchNameColumnName,
    set$db$columns$batchesTableColumns,
    set$db$tables$batchesTableName
  )

  #ensure typesPrimaryKey is in dataTable
  checkForMissingColumn(
    set$db$keys$typesPrimaryKey,
    set$db$columns$dataTableColumns,
    set$db$tables$dataTableName
  )

  #ensure batchesPrimayKey is in dataTable
  checkForMissingColumn(
    set$db$keys$batchesPrimaryKey,
    set$db$columns$dataTableColumns,
    set$db$tables$dataTableName
  )
}

# Utility function that converts the results of as.list(match.call()) back to a
# call object and evaluates the call.  Used to call .dpSet() from a paramList
# generated inside dpSet() or loaded from disk by dpLoadSet()
.dpSetFromParamList = function(paramList) {
  thisCall = do.call(call, c(list(".dpSet"), paramList))
  newSet = eval(thisCall)
  return(newSet)
}

# Saving a dpSet object to disk directly runs the risk of the dpSet becomming
# out of date.  To avoid this problem, .dpSet() is an internal function called
# by dpSet() that generates a dpSet object from the arguments originally passed
# to dpSet(). dpSet() creates, executes, and saves a call to .dpSet() on disk,
# in the set's folder.  This saved call can be used to recreate a dpSet object
# from the same parameters in the future (i.e., "load the dpSet from disk")
# using: eval(callLoadedFromDisk). Thus, the resulting dpSet object will always
# be regenerated with the latest version of .dpSet(). Further, the parameters
# for the call saved on disk can be easily modified to add or remove parameters,
# if the parameters required by dpSet() change in the future.  Calls are s3
# objects built atop named lists, so code can load the call, modify the contents
# of the list, and resave the call to disk.
.dpSet = function(...) {

  # creates variables in this environment from the ... parameter
  unpackDots(...)

  connection = dpConnect(connectionParams)

  newSet =
    list(
      setPath = setPath,
      connectionParams = connectionParams,
      db = list (
        tables = list(
          batchesTableName = batchesTableName,
          dataTableName = dataTableName,
          typesTableName = typesTableName
        ),
        columns = list(
          batchesTableColumns = RODBC::sqlColumns(connection, batchesTableName)$COLUMN_NAME,
          dataTableColumns = RODBC::sqlColumns(connection, dataTableName)$COLUMN_NAME,
          typesTableColumns = RODBC::sqlColumns(connection, typesTableName)$COLUMN_NAME
        ),
        keys = list(
          batchesPrimaryKey = RODBC::sqlPrimaryKeys(connection, batchesTableName)$COLUMN_NAME,
          dataPrimaryKey = RODBC::sqlPrimaryKeys(connection, dataTableName)$COLUMN_NAME,
          typesPrimaryKey = RODBC::sqlPrimaryKeys(connection, typesTableName)$COLUMN_NAME
        ),
        batchRowColumnName = batchRowColumnName,
        datumValueColumnName = datumValueColumnName,
        datumTypeColumnName = datumTypeColumnName,
        batchNameColumnName = batchNameColumnName
      )
    )
  RODBC::odbcClose(connection)
  class(newSet) = "dpSet"

  # Checks to be sure that tables and columns are consistent with database
  .dpValidateSet(newSet)

  return(newSet)

}


